/**
 * 404 Detection Test Suite
 * Zero tolerance for broken routes - MANDATORY for all tracks
 * Generated by CCU Framework
 */

import { test, expect } from '@playwright/test';

// Configuration for different track types
const TRACK_CONFIG = {
  instant: {
    timeout: 5000,
    maxRetries: 1,
    routes: ['/', '/api/health']
  },
  rapid: {
    timeout: 10000,
    maxRetries: 2,
    routes: ['/', '/api/**', '/admin/**']
  },
  standard: {
    timeout: 15000,
    maxRetries: 3,
    routes: ['/', '/api/**', '/admin/**', '/dashboard/**']
  },
  enterprise: {
    timeout: 30000,
    maxRetries: 3,
    routes: ['/', '/api/**', '/admin/**', '/dashboard/**', '/reports/**', '/analytics/**']
  }
};

const track = process.env.CCU_TRACK || 'standard';
const config = TRACK_CONFIG[track];

test.describe('404 Detection - Zero Tolerance', () => {
  test.setTimeout(config.timeout);

  test('No 404 errors on main route', async ({ page }) => {
    const response = await page.goto('/');
    expect(response?.status()).not.toBe(404);
    expect(response?.status()).toBeLessThan(400);
  });

  test('No 404 errors on API health check', async ({ page }) => {
    const response = await page.goto('/api/health');
    expect(response?.status()).not.toBe(404);
    // Health check should return 200 or 204
    expect([200, 204]).toContain(response?.status());
  });

  test('No console 404 errors during navigation', async ({ page }) => {
    const consoleLogs: string[] = [];
    const errors404: string[] = [];

    // Monitor console for 404 errors
    page.on('console', msg => {
      const text = msg.text();
      consoleLogs.push(text);
      if (text.includes('404') || text.includes('Not Found')) {
        errors404.push(text);
      }
    });

    // Monitor network for 404 responses
    page.on('response', response => {
      if (response.status() === 404) {
        errors404.push(`404: ${response.url()}`);
      }
    });

    await page.goto('/');
    
    // Navigate through common routes based on track
    if (track !== 'instant') {
      await page.waitForTimeout(1000);
      
      // Check for navigation links
      const links = await page.$$('a[href^="/"]');
      for (const link of links.slice(0, 5)) { // Check first 5 links
        const href = await link.getAttribute('href');
        if (href && !href.startsWith('http')) {
          await page.goto(href);
        }
      }
    }

    // Assert no 404 errors found
    expect(errors404, `Found 404 errors: ${errors404.join(', ')}`).toHaveLength(0);
  });

  test('API endpoints return valid responses', async ({ request }) => {
    const apiEndpoints = [
      '/api/health',
      '/api/status',
      '/api/version'
    ];

    for (const endpoint of apiEndpoints) {
      const response = await request.get(endpoint, {
        failOnStatusCode: false
      });
      
      // Skip if endpoint doesn't exist (might not be implemented yet)
      if (response.status() === 404) {
        console.log(`Skipping ${endpoint} - not implemented yet`);
        continue;
      }
      
      expect(response.status()).toBeLessThan(400);
    }
  });

  test('Static assets load without 404', async ({ page }) => {
    await page.goto('/');
    
    // Check all loaded resources
    const failedResources: string[] = [];
    
    page.on('requestfailed', request => {
      failedResources.push(request.url());
    });
    
    page.on('response', response => {
      if (response.status() === 404) {
        failedResources.push(`404: ${response.url()}`);
      }
    });
    
    await page.waitForLoadState('networkidle');
    
    // Filter out expected failures (like favicon in development)
    const unexpectedFailures = failedResources.filter(url => 
      !url.includes('favicon.ico') && 
      !url.includes('_next/static') // Next.js dev mode
    );
    
    expect(unexpectedFailures, `Failed to load resources: ${unexpectedFailures.join(', ')}`).toHaveLength(0);
  });
});

// Module-specific 404 tests
test.describe('Module-Specific 404 Detection', () => {
  test('Module routes are accessible', async ({ page }) => {
    const moduleRoutes = process.env.CCU_MODULE_ROUTES?.split(',') || [];
    
    if (moduleRoutes.length === 0) {
      test.skip();
      return;
    }
    
    for (const route of moduleRoutes) {
      const response = await page.goto(route);
      expect(response?.status(), `Route ${route} returned 404`).not.toBe(404);
    }
  });
});

// MANDATORY: Test must fail if ANY 404 is detected
test.describe('404 Zero Tolerance Gate', () => {
  test('MANDATORY: No 404 errors allowed', async ({ page }) => {
    let has404 = false;
    
    page.on('response', response => {
      if (response.status() === 404) {
        has404 = true;
        console.error(`❌ 404 DETECTED: ${response.url()}`);
      }
    });
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    if (has404) {
      throw new Error('❌ 404 ERRORS DETECTED - ZERO TOLERANCE POLICY VIOLATED');
    }
    
    expect(has404).toBe(false);
  });
});